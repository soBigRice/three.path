// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";class s{constructor(){this.pos=new e.Vector3,this.dir=new e.Vector3,this.right=new e.Vector3,this.up=new e.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const i=new e.Vector3,r=new e.Vector3,n=new e.Vector3,a=new e.Matrix4,o=new e.QuadraticBezierCurve3;class u extends e.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,s){this.setAttribute("position",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),s&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new e.Uint32BufferAttribute(3*t,1):new e.Uint16BufferAttribute(3*t,1))}_initByData(t,s={},i,r){const n=c(t,s,r);n&&0!==n.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(n.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(n.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(n.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(n.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(n.position.length/3>65536?new e.Uint32BufferAttribute(n.indices,1):new e.Uint16BufferAttribute(n.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=c(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}_resizeAttribute(t,s){let i=this.getAttribute(t);for(;i.array.length<s;){const s=i.array.length,r=new e.BufferAttribute(new Float32Array(2*s),i.itemSize,i.normalized);r.name=i.name,r.usage=i.usage,this.setAttribute(t,r),i=r}}_resizeIndex(t){let s=this.getIndex();for(;s.array.length<t;){const t=s.array.length,i=new e.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);i.name=s.name,i.usage=s.usage,this.setIndex(i),s=i}}_updateAttributes(t,e,s,i,r){this._resizeAttribute("position",t.length);const n=this.getAttribute("position");n.array.set(t,0),n.addUpdateRange?(n.clearUpdateRanges(),n.addUpdateRange(0,t.length)):n.updateRange.count=t.length,n.needsUpdate=!0,this._resizeAttribute("normal",e.length);const a=this.getAttribute("normal");a.array.set(e,0),a.addUpdateRange?(a.clearUpdateRanges(),a.addUpdateRange(0,e.length)):a.updateRange.count=e.length,a.needsUpdate=!0,this._resizeAttribute("uv",s.length);const o=this.getAttribute("uv");if(o.array.set(s,0),o.addUpdateRange?(o.clearUpdateRanges(),o.addUpdateRange(0,s.length)):o.updateRange.count=s.length,o.needsUpdate=!0,i){this._resizeAttribute("uv2",i.length);const t=this.getAttribute("uv2");t.array.set(i,0),t.addUpdateRange?(t.clearUpdateRanges(),t.addUpdateRange(0,i.length)):t.updateRange.count=i.length,t.needsUpdate=!0}this._resizeIndex(r.length);const u=this.getIndex();u.set(r,0),u.addUpdateRange?(u.clearUpdateRanges(),u.addUpdateRange(0,r.length)):u.updateRange.count=r.length,u.needsUpdate=!0}}function c(t,i,r=!1){const n=i.width||.1,a=void 0!==i.progress?i.progress:1,o=void 0===i.arrow||i.arrow,u=void 0!==i.side?i.side:"both",c=n/2,h="both"!==u?n/2:n,d=t.distance(),l=a*d;if(0==d)return null;const p=c/h,g=c/d;let y=0;const f=[],w=[],b=[],A=[],m=[];let x=0;const z=new e.Vector3,U=new e.Vector3,v=new e.Vector3,V=new e.Vector3,B=new e.Vector3,S=new e.Vector3;function _(t){const e=0===f.length,s=t.sharp&&!e,i=t.dist/h,n=t.dist/d,a=t.dir,o=t.up,l=t.right;if("left"!==u?z.copy(l).multiplyScalar(c*t.widthScale):z.set(0,0,0),"right"!==u?U.copy(l).multiplyScalar(-c*t.widthScale):U.set(0,0,0),z.add(t.pos),U.add(t.pos),s){v.fromArray(f,f.length-6).sub(U),V.fromArray(f,f.length-3).sub(z);const t=v.length()-V.length();let e,s;t>0?(e=v,s=U):(e=V,s=z),B.copy(e).setLength(Math.abs(t)).add(s);const u=S.copy(s).sub(B).normalize().dot(a)*S.copy(s).sub(B).length()*2;S.copy(a).setLength(u).add(B),t>0?(f.push(B.x,B.y,B.z,z.x,z.y,z.z,U.x,U.y,U.z,z.x,z.y,z.z,S.x,S.y,S.z,z.x,z.y,z.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-4,x-6,x-5,x-2,x-4,x-1),y+=12):(f.push(U.x,U.y,U.z,B.x,B.y,B.z,U.x,U.y,U.z,z.x,z.y,z.z,U.x,U.y,U.z,S.x,S.y,S.z),x+=6,m.push(x-6,x-8,x-7,x-6,x-7,x-5,x-6,x-5,x-3,x-2,x-3,x-1),y+=12),w.push(o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z),b.push(i-p,0,i-p,1,i,0,i,1,i+p,0,i+p,1),r&&A.push(n-g,0,n-g,1,n,0,n,1,n+g,0,n+g,1)}else f.push(U.x,U.y,U.z,z.x,z.y,z.z),w.push(o.x,o.y,o.z,o.x,o.y,o.z),b.push(i,0,i,1),r&&A.push(n,0,n,1),x+=2,e||(m.push(x-2,x-4,x-3,x-2,x-3,x-1),y+=6)}const R=new e.Vector3;let M;if(l>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>l){const r=t.array[e-1];M=new s;const n=(l-r.dist)/(i.dist-r.dist);M.lerpPathPoints(r,i,n),_(M);break}_(i)}else M=t.array[0];return o&&(M=M||t.array[t.count-1],function(t){const e=t.dir,s=t.up,i=t.right,a=t.dist/h,o=t.dist/d;"left"!==u?z.copy(i).multiplyScalar(2*c):z.set(0,0,0),"right"!==u?U.copy(i).multiplyScalar(2*-c):U.set(0,0,0),R.copy(e).setLength(3*c),z.add(t.pos),U.add(t.pos),R.add(t.pos),f.push(U.x,U.y,U.z,z.x,z.y,z.z,R.x,R.y,R.z),w.push(s.x,s.y,s.z,s.x,s.y,s.z,s.x,s.y,s.z),b.push(a,"both"!==u?"right"!==u?-2:0:-.5,a,"both"!==u?"left"!==u?2:0:1.5,a+1.5,"both"!==u?0:.5),r&&A.push(o,"both"!==u?"right"!==u?-2:0:-.5,o,"both"!==u?"left"!==u?2:0:1.5,o+1.5*n/d,"both"!==u?0:.5),x+=3,m.push(x-1,x-3,x-2),y+=3}(M)),{position:f,normal:w,uv:b,uv2:A,indices:m,count:y}}function h(t,i,r=!1){const n=i.radius||.1,a=void 0!==i.progress?i.progress:1,o=Math.max(2,i.radialSegments||8),u=i.startRad||0,c=2*n*Math.PI,h=t.distance(),d=a*h;if(0==d)return null;let l=0;const p=[],g=[],y=[],f=[],w=[];let b=0;const A=new e.Vector3;function m(t,e,s){const i=0===p.length,n=t.dist/c,a=t.dist/h;for(let i=0;i<=s;i++){let o=i;o==s&&(o=0),A.copy(t.up).applyAxisAngle(t.dir,u+2*Math.PI*o/s).normalize(),p.push(t.pos.x+A.x*e*t.widthScale,t.pos.y+A.y*e*t.widthScale,t.pos.z+A.z*e*t.widthScale),g.push(A.x,A.y,A.z),y.push(n,i/s),r&&f.push(a,i/s),b++}if(!i){const t=b-2*(s+1),e=b-(s+1);for(let i=0;i<s;i++)w.push(e+i,t+i,t+i+1,e+i,t+i+1,e+i+1),l+=6}}if(d>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>d){const r=t.array[e-1],a=new s,u=(d-r.dist)/(i.dist-r.dist);a.lerpPathPoints(r,i,u),m(a,n,o);break}m(i,n,o)}return{position:p,normal:g,uv:y,uv2:f,indices:w,count:l}}function d(t,i,r=!1){const n=i.radius||.1,a=void 0!==i.progress?i.progress:1,o=i.width||1,u=i.height||.5,c=2*n*Math.PI,h=t.distance(),d=a*h;if(0==d)return null;let l=0;const p=[],g=[],y=[],f=[],w=[];let b=0;function A(t,e,s){const i=0===p.length,n=t.dist/c,a=t.dist/h;for(let i=0;i<=4;i++){const o=t.pos.clone(),u=t.up.clone().cross(t.dir.clone()).normalize(),c=t.up.clone().normalize().multiplyScalar(s/2);2!=i&&3!=i||c.negate();const h=u.clone().multiplyScalar(e/2);1!=i&&2!=i||h.negate();const d=o.clone().add(c).add(h);p.push(d.x,d.y,d.z),g.push(u.x,u.y,u.z),y.push(n,i/4),r&&f.push(a,i/4),b++}if(!i){const t=b-10,e=b-5;for(let s=0;s<4;s++)w.push(e+s,t+s,t+s+1,e+s,t+s+1,e+s+1),l+=6}}if(new e.Vector3,d>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>d){const r=t.array[e-1],n=new s,a=(d-r.dist)/(i.dist-r.dist);n.lerpPathPoints(r,i,a),A(n,o,u);break}A(i,o,u)}return{position:p,normal:g,uv:y,uv2:f,indices:w,count:l}}t.PathGeometry=u,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,s=.1,i=10,r=null,n=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);n&&!t[0].equals(t[t.length-1])&&t.push((new e.Vector3).copy(t[0]));for(let e=0,a=t.length;e<a;e++)if(0===e)this._start(t[e],t[e+1],r);else if(e===a-1)if(n){this._corner(t[e],t[1],s,i,r);const n=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=n}else this._end(t[e]);else this._corner(t[e],t[e+1],s,i,r)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new s),this.array[t]}_start(t,e,s){this.count=0;const i=this._getByIndex(this.count);if(i.pos.copy(t),i.dir.subVectors(e,t),s)i.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(i.dir.x),s=Math.abs(i.dir.y),r=Math.abs(i.dir.z);e<t&&(t=e,i.up.set(1,0,0)),s<t&&(t=s,i.up.set(0,1,0)),r<t&&i.up.set(0,0,1)}i.right.crossVectors(i.dir,i.up).normalize(),i.up.crossVectors(i.right,i.dir).normalize(),i.dist=0,i.widthScale=1,i.sharp=!1,i.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],s=this._getByIndex(this.count);s.pos.copy(t),s.dir.subVectors(t,e.pos);const r=s.dir.length();s.dir.normalize(),s.up.copy(e.up);const n=i.crossVectors(e.dir,s.dir);if(n.length()>Number.EPSILON){n.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(s.dir),-1),1));s.up.applyMatrix4(a.makeRotationAxis(n,t))}s.right.crossVectors(s.dir,s.up).normalize(),s.dist=e.dist+r,s.widthScale=1,s.sharp=!1,this.count++}_corner(t,e,s,n,a){if(s>0&&n>0){const u=function(t,e,s,n,a,o){const u=i.subVectors(e,t),c=r.subVectors(s,e),h=u.length(),d=c.length();u.normalize(),c.normalize();const l=Math.min(.999999*(a?h/2:h),n);o.v0.copy(e).sub(u.multiplyScalar(l)),o.v1.copy(e);const p=Math.min(d/2*.999999,n);return o.v2.copy(e).add(c.multiplyScalar(p)),o}(this.array[this.count-1].pos,t,e,s,this.count-1==0,o),c=u.getPoints(n);for(let t=0;t<n;t++)this._sharpCorner(c[t],c[t+1],a,0===t?1:0);c[n].equals(e)||this._sharpCorner(c[n],e,a,2)}else this._sharpCorner(t,e,a,0,!0)}_sharpCorner(t,e,s,o=0,u=!1){const c=this.array[this.count-1],h=this._getByIndex(this.count),d=i.subVectors(t,c.pos),l=r.subVectors(e,t),p=d.length();if(d.normalize(),l.normalize(),h.pos.copy(t),1===o?h.dir.copy(d):2===o?h.dir.copy(l):(h.dir.addVectors(d,l),h.dir.normalize()),s)1===h.dir.dot(s)?h.right.crossVectors(l,s).normalize():h.right.crossVectors(h.dir,s).normalize(),h.up.crossVectors(h.right,h.dir).normalize();else{h.up.copy(c.up);const t=n.crossVectors(c.dir,h.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(c.dir.dot(h.dir),-1),1));h.up.applyMatrix4(a.makeRotationAxis(t,e))}h.right.crossVectors(h.dir,h.up).normalize()}h.dist=c.dist+p;const g=d.dot(l);h.widthScale=Math.min(1/Math.sqrt((1+g)/2),1.415)||1,h.sharp=Math.abs(g-1)>.05&&u,this.count++}},t.PathRectangleGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},i,r){const n=d(t,s,r);n&&0!==n.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(n.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(n.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(n.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(n.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(n.position.length/3>65536?new e.Uint32BufferAttribute(n.indices,1):new e.Uint16BufferAttribute(n.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=d(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}},t.PathTubeGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},i,r){const n=h(t,s,r);n&&0!==n.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(n.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(n.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(n.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(n.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(n.position.length/3>65536?new e.Uint32BufferAttribute(n.indices,1):new e.Uint16BufferAttribute(n.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=h(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}}}));
