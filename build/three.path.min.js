// github.com/shawn0326/three.path
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";class s{constructor(){this.pos=new e.Vector3,this.dir=new e.Vector3,this.right=new e.Vector3,this.up=new e.Vector3,this.dist=0,this.widthScale=1,this.sharp=!1}lerpPathPoints(t,e,s){this.pos.lerpVectors(t.pos,e.pos,s),this.dir.lerpVectors(t.dir,e.dir,s),this.up.lerpVectors(t.up,e.up,s),this.right.lerpVectors(t.right,e.right,s),this.dist=(e.dist-t.dist)*s+t.dist,this.widthScale=(e.widthScale-t.widthScale)*s+t.widthScale}copy(t){this.pos.copy(t.pos),this.dir.copy(t.dir),this.up.copy(t.up),this.right.copy(t.right),this.dist=t.dist,this.widthScale=t.widthScale}}const i=new e.Vector3,r=new e.Vector3,a=new e.Vector3,n=new e.Matrix4,o=new e.QuadraticBezierCurve3;class u extends e.BufferGeometry{constructor(t=3e3,e=!1){super(),isNaN(t)?this._initByData(t.pathPointList,t.options,t.usage,e):this._initByMaxVertex(t,e)}_initByMaxVertex(t,s){this.setAttribute("position",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(3*t),3).setUsage(e.DynamicDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),s&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(2*t),2).setUsage(e.DynamicDrawUsage)),this.drawRange.start=0,this.drawRange.count=0,this.setIndex(t>65536?new e.Uint32BufferAttribute(3*t,1):new e.Uint16BufferAttribute(3*t,1))}_initByData(t,s={},i,r){const a=c(t,s,r);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=c(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}_resizeAttribute(t,s){let i=this.getAttribute(t);for(;i.array.length<s;){const s=i.array.length,r=new e.BufferAttribute(new Float32Array(2*s),i.itemSize,i.normalized);r.name=i.name,r.usage=i.usage,this.setAttribute(t,r),i=r}}_resizeIndex(t){let s=this.getIndex();for(;s.array.length<t;){const t=s.array.length,i=new e.BufferAttribute(2*t>65535?new Uint32Array(2*t):new Uint16Array(2*t),1);i.name=s.name,i.usage=s.usage,this.setIndex(i),s=i}}_updateAttributes(t,e,s,i,r){this._resizeAttribute("position",t.length);const a=this.getAttribute("position");a.array.set(t,0),a.addUpdateRange?(a.clearUpdateRanges(),a.addUpdateRange(0,t.length)):a.updateRange.count=t.length,a.needsUpdate=!0,this._resizeAttribute("normal",e.length);const n=this.getAttribute("normal");n.array.set(e,0),n.addUpdateRange?(n.clearUpdateRanges(),n.addUpdateRange(0,e.length)):n.updateRange.count=e.length,n.needsUpdate=!0,this._resizeAttribute("uv",s.length);const o=this.getAttribute("uv");if(o.array.set(s,0),o.addUpdateRange?(o.clearUpdateRanges(),o.addUpdateRange(0,s.length)):o.updateRange.count=s.length,o.needsUpdate=!0,i){this._resizeAttribute("uv2",i.length);const t=this.getAttribute("uv2");t.array.set(i,0),t.addUpdateRange?(t.clearUpdateRanges(),t.addUpdateRange(0,i.length)):t.updateRange.count=i.length,t.needsUpdate=!0}this._resizeIndex(r.length);const u=this.getIndex();u.set(r,0),u.addUpdateRange?(u.clearUpdateRanges(),u.addUpdateRange(0,r.length)):u.updateRange.count=r.length,u.needsUpdate=!0}}function c(t,i,r=!1){const a=i.width||.1,n=void 0!==i.progress?i.progress:1,o=void 0===i.arrow||i.arrow,u=void 0!==i.side?i.side:"both",c=a/2,h="both"!==u?a/2:a,l=t.distance(),d=n*l;if(0==l)return null;const p=c/h,y=c/l;let g=0;const f=[],w=[],b=[],m=[],A=[];let x=0;const z=new e.Vector3,U=new e.Vector3,S=new e.Vector3,v=new e.Vector3,V=new e.Vector3,B=new e.Vector3;function _(t){const e=0===f.length,s=t.sharp&&!e,i=t.dist/h,a=t.dist/l,n=t.dir,o=t.up,d=t.right;if("left"!==u?z.copy(d).multiplyScalar(c*t.widthScale):z.set(0,0,0),"right"!==u?U.copy(d).multiplyScalar(-c*t.widthScale):U.set(0,0,0),z.add(t.pos),U.add(t.pos),s){S.fromArray(f,f.length-6).sub(U),v.fromArray(f,f.length-3).sub(z);const t=S.length()-v.length();let e,s;t>0?(e=S,s=U):(e=v,s=z),V.copy(e).setLength(Math.abs(t)).add(s);const u=B.copy(s).sub(V).normalize().dot(n)*B.copy(s).sub(V).length()*2;B.copy(n).setLength(u).add(V),t>0?(f.push(V.x,V.y,V.z,z.x,z.y,z.z,U.x,U.y,U.z,z.x,z.y,z.z,B.x,B.y,B.z,z.x,z.y,z.z),x+=6,A.push(x-6,x-8,x-7,x-6,x-7,x-5,x-4,x-6,x-5,x-2,x-4,x-1),g+=12):(f.push(U.x,U.y,U.z,V.x,V.y,V.z,U.x,U.y,U.z,z.x,z.y,z.z,U.x,U.y,U.z,B.x,B.y,B.z),x+=6,A.push(x-6,x-8,x-7,x-6,x-7,x-5,x-6,x-5,x-3,x-2,x-3,x-1),g+=12),w.push(o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z,o.x,o.y,o.z),b.push(i-p,0,i-p,1,i,0,i,1,i+p,0,i+p,1),r&&m.push(a-y,0,a-y,1,a,0,a,1,a+y,0,a+y,1)}else f.push(U.x,U.y,U.z,z.x,z.y,z.z),w.push(o.x,o.y,o.z,o.x,o.y,o.z),b.push(i,0,i,1),r&&m.push(a,0,a,1),x+=2,e||(A.push(x-2,x-4,x-3,x-2,x-3,x-1),g+=6)}const R=new e.Vector3;let M;if(d>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>d){const r=t.array[e-1];M=new s;const a=(d-r.dist)/(i.dist-r.dist);M.lerpPathPoints(r,i,a),_(M);break}_(i)}else M=t.array[0];return o&&(M=M||t.array[t.count-1],function(t){const e=t.dir,s=t.up,i=t.right,n=t.dist/h,o=t.dist/l;"left"!==u?z.copy(i).multiplyScalar(2*c):z.set(0,0,0),"right"!==u?U.copy(i).multiplyScalar(2*-c):U.set(0,0,0),R.copy(e).setLength(3*c),z.add(t.pos),U.add(t.pos),R.add(t.pos),f.push(U.x,U.y,U.z,z.x,z.y,z.z,R.x,R.y,R.z),w.push(s.x,s.y,s.z,s.x,s.y,s.z,s.x,s.y,s.z),b.push(n,"both"!==u?"right"!==u?-2:0:-.5,n,"both"!==u?"left"!==u?2:0:1.5,n+1.5,"both"!==u?0:.5),r&&m.push(o,"both"!==u?"right"!==u?-2:0:-.5,o,"both"!==u?"left"!==u?2:0:1.5,o+1.5*a/l,"both"!==u?0:.5),x+=3,A.push(x-1,x-3,x-2),g+=3}(M)),{position:f,normal:w,uv:b,uv2:m,indices:A,count:g}}function h(t,i,r=!1){const a=i.radius||.1,n=void 0!==i.progress?i.progress:1,o=Math.max(2,i.radialSegments||8),u=i.startRad||0,c=2*a*Math.PI,h=t.distance(),l=n*h;if(0==l)return null;let d=0;const p=[],y=[],g=[],f=[],w=[];let b=0;const m=new e.Vector3;function A(t,e,s){const i=0===p.length,a=t.dist/c,n=t.dist/h;for(let i=0;i<=s;i++){let o=i;o==s&&(o=0),m.copy(t.up).applyAxisAngle(t.dir,u+2*Math.PI*o/s).normalize(),p.push(t.pos.x+m.x*e*t.widthScale,t.pos.y+m.y*e*t.widthScale,t.pos.z+m.z*e*t.widthScale),y.push(m.x,m.y,m.z),g.push(a,i/s),r&&f.push(n,i/s),b++}if(!i){const t=b-2*(s+1),e=b-(s+1);for(let i=0;i<s;i++)w.push(e+i,t+i,t+i+1,e+i,t+i+1,e+i+1),d+=6}}if(l>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>l){const r=t.array[e-1],n=new s,u=(l-r.dist)/(i.dist-r.dist);n.lerpPathPoints(r,i,u),A(n,a,o);break}A(i,a,o)}return{position:p,normal:y,uv:g,uv2:f,indices:w,count:d}}function l(t,e,i=!1){const r=void 0!==e.progress?e.progress:1,a=e.width||1,n=e.height||.5,o=t.distance(),u=r*o;if(0==u)return null;let c=0;const h=[],l=[],d=[],p=[],y=a/2,g=n/2,f=2*(a+n);function w(t){const e=t.pos.clone(),s=t.up.clone(),i=t.right.clone(),r=e.clone().add(s.clone().multiplyScalar(g)).add(i.clone().multiplyScalar(-y)),u=e.clone().add(s.clone().multiplyScalar(g)).add(i.clone().multiplyScalar(-y)),p=e.clone().add(s.clone().multiplyScalar(g)).add(i.clone().multiplyScalar(y)),w=e.clone().add(s.clone().multiplyScalar(g)).add(i.clone().multiplyScalar(y)),b=e.clone().add(s.clone().multiplyScalar(-g)).add(i.clone().multiplyScalar(y)),m=e.clone().add(s.clone().multiplyScalar(-g)).add(i.clone().multiplyScalar(y)),A=e.clone().add(s.clone().multiplyScalar(-g)).add(i.clone().multiplyScalar(-y)),x=e.clone().add(s.clone().multiplyScalar(-g)).add(i.clone().multiplyScalar(-y));h.push(u.x,u.y,u.z),h.push(p.x,p.y,p.z),h.push(w.x,w.y,w.z),h.push(b.x,b.y,b.z),h.push(m.x,m.y,m.z),h.push(A.x,A.y,A.z),h.push(x.x,x.y,x.z),h.push(r.x,r.y,r.z);const z=i.clone().negate().normalize(),U=s.clone().normalize(),S=U.clone(),v=z.clone().negate(),V=v.clone(),B=S.clone().negate(),_=B.clone(),R=z.clone();l.push(U.x,U.y,U.z),l.push(S.x,S.y,S.z),l.push(v.x,v.y,v.z),l.push(V.x,V.y,V.z),l.push(B.x,B.y,B.z),l.push(_.x,_.y,_.z),l.push(R.x,R.y,R.z),l.push(z.x,z.y,z.z);const M=t.dist/o;d.push(M,0),d.push(M,a/f),d.push(M,a/f),d.push(M,(n+a)/f),d.push(M,(n+a)/f),d.push(M,(2*a+n)/f),d.push(M,(2*a+n)/f),d.push(M,1),c+=8}if(u>0)for(let e=0;e<t.count;e++){const i=t.array[e];if(i.dist>u){const r=t.array[e-1],a=new s,n=(u-r.dist)/(i.dist-r.dist);a.lerpPathPoints(r,i,n),w(a);break}w(i)}const b=h.length/3;for(let t=0;t<b;t+=8)if(t+8<c){const e=t,s=t+8,i=t+1,r=t+8+1,a=t+2,n=t+8+2,o=t+3,u=t+8+3,c=t+4,h=t+8+4,l=t+5,d=t+8+5,y=t+6,g=t+8+6,f=t+7,w=t+8+7;p.push(e,i,r),p.push(e,r,s),p.push(a,o,u),p.push(a,u,n),p.push(c,l,d),p.push(c,d,h),p.push(y,f,w),p.push(y,w,g)}return{position:h,normal:l,uv:d,uv2:[],indices:p,count:c}}t.PathGeometry=u,t.PathPointList=class{constructor(){this.array=[],this.count=0}set(t,s=.1,i=10,r=null,a=!1){if((t=t.slice(0)).length<2)return console.warn("PathPointList: points length less than 2."),void(this.count=0);a&&!t[0].equals(t[t.length-1])&&t.push((new e.Vector3).copy(t[0]));for(let e=0,n=t.length;e<n;e++)if(0===e)this._start(t[e],t[e+1],r);else if(e===n-1)if(a){this._corner(t[e],t[1],s,i,r);const a=this.array[0].dist;this.array[0].copy(this.array[this.count-1]),this.array[0].dist=a}else this._end(t[e]);else this._corner(t[e],t[e+1],s,i,r)}distance(){return this.count>0?this.array[this.count-1].dist:0}_getByIndex(t){return this.array[t]||(this.array[t]=new s),this.array[t]}_start(t,e,s){this.count=0;const i=this._getByIndex(this.count);if(i.pos.copy(t),i.dir.subVectors(e,t),s)i.up.copy(s);else{let t=Number.MAX_VALUE;const e=Math.abs(i.dir.x),s=Math.abs(i.dir.y),r=Math.abs(i.dir.z);e<t&&(t=e,i.up.set(1,0,0)),s<t&&(t=s,i.up.set(0,1,0)),r<t&&i.up.set(0,0,1)}i.right.crossVectors(i.dir,i.up).normalize(),i.up.crossVectors(i.right,i.dir).normalize(),i.dist=0,i.widthScale=1,i.sharp=!1,i.dir.normalize(),this.count++}_end(t){const e=this.array[this.count-1],s=this._getByIndex(this.count);s.pos.copy(t),s.dir.subVectors(t,e.pos);const r=s.dir.length();s.dir.normalize(),s.up.copy(e.up);const a=i.crossVectors(e.dir,s.dir);if(a.length()>Number.EPSILON){a.normalize();const t=Math.acos(Math.min(Math.max(e.dir.dot(s.dir),-1),1));s.up.applyMatrix4(n.makeRotationAxis(a,t))}s.right.crossVectors(s.dir,s.up).normalize(),s.dist=e.dist+r,s.widthScale=1,s.sharp=!1,this.count++}_corner(t,e,s,a,n){if(s>0&&a>0){const u=function(t,e,s,a,n,o){const u=i.subVectors(e,t),c=r.subVectors(s,e),h=u.length(),l=c.length();u.normalize(),c.normalize();const d=Math.min(.999999*(n?h/2:h),a);o.v0.copy(e).sub(u.multiplyScalar(d)),o.v1.copy(e);const p=Math.min(l/2*.999999,a);return o.v2.copy(e).add(c.multiplyScalar(p)),o}(this.array[this.count-1].pos,t,e,s,this.count-1==0,o),c=u.getPoints(a);for(let t=0;t<a;t++)this._sharpCorner(c[t],c[t+1],n,0===t?1:0);c[a].equals(e)||this._sharpCorner(c[a],e,n,2)}else this._sharpCorner(t,e,n,0,!0)}_sharpCorner(t,e,s,o=0,u=!1){const c=this.array[this.count-1],h=this._getByIndex(this.count),l=i.subVectors(t,c.pos),d=r.subVectors(e,t),p=l.length();if(l.normalize(),d.normalize(),h.pos.copy(t),1===o?h.dir.copy(l):2===o?h.dir.copy(d):(h.dir.addVectors(l,d),h.dir.normalize()),s)1===h.dir.dot(s)?h.right.crossVectors(d,s).normalize():h.right.crossVectors(h.dir,s).normalize(),h.up.crossVectors(h.right,h.dir).normalize();else{h.up.copy(c.up);const t=a.crossVectors(c.dir,h.dir);if(t.length()>Number.EPSILON){t.normalize();const e=Math.acos(Math.min(Math.max(c.dir.dot(h.dir),-1),1));h.up.applyMatrix4(n.makeRotationAxis(t,e))}h.right.crossVectors(h.dir,h.up).normalize()}h.dist=c.dist+p;const y=l.dot(d);h.widthScale=Math.min(1/Math.sqrt((1+y)/2),1.415)||1,h.sharp=Math.abs(y-1)>.05&&u,this.count++}},t.PathRectangleGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},i,r){const a=l(t,s,r);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=l(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}},t.PathTubeGeometry=class extends u{constructor(t=1e3,e=!1){super(t,e)}_initByData(t,s={},i,r){const a=h(t,s,r);a&&0!==a.count?(this.setAttribute("position",new e.BufferAttribute(new Float32Array(a.position),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("normal",new e.BufferAttribute(new Float32Array(a.normal),3).setUsage(i||e.StaticDrawUsage)),this.setAttribute("uv",new e.BufferAttribute(new Float32Array(a.uv),2).setUsage(i||e.StaticDrawUsage)),r&&this.setAttribute("uv2",new e.BufferAttribute(new Float32Array(a.uv2),2).setUsage(i||e.StaticDrawUsage)),this.setIndex(a.position.length/3>65536?new e.Uint32BufferAttribute(a.indices,1):new e.Uint16BufferAttribute(a.indices,1))):this._initByMaxVertex(2,r)}update(t,e={}){const s=!!this.getAttribute("uv2"),i=h(t,e,s);i?(this._updateAttributes(i.position,i.normal,i.uv,s?i.uv2:null,i.indices),this.drawRange.count=i.count):this.drawRange.count=0}}}));
